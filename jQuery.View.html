<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>jQueryMX  - jQuery.View</title>
	<meta name="description" content="">
	<meta name="author" content="">
	
	<link rel="stylesheet" type="text/css" href="./static/bundles/static.css">
	
	<!--[if lt IE 9]>
   <script type="text/javascript" src="static/html5shiv.js"></script>
    <!--<![endif]-->
</head>

<body class="docs">
	<header>
		<nav class="container">

			<div class="logo-menu">
				<a class="brand" href="./index.html">jQueryMX</a>
			</div>

			<div class="pull-right">
				<div class="bitovi-menu">
					<a href="http://bitovi.com" class="bitovi icon-bits">Bitovi</a>
					<ul class="dropdown-menu">
						<li><a href="http://bitovi.com">Bitovi.com</a></li>
						<li><a href="http://bitovi.com/blog/">Blog</a></li>
						<li><a href="http://bitovi.com/consulting/">Consulting</a></li>
						<li><a href="http://bitovi.com/training/">Training</a></li>
						<li><a href="http://bitovi.com/open-source/">Open Source</a></li>
						<li><a href="http://bitovi.com/people/">People</a></li>
						<li><a href="http://bitovi.com/contact/">Contact Us</a></li>
					</ul>
				</div>
			</div>
		</nav>
	</header>

	
<div class="container api">

	
	<nav class="sidebar">
		
		<ul class="api cascading primary-grouping"> 
	
		
		<li class="search-container active parent">
			<a class="sidebar-title" href="index.html" data-search="jQueryMX">
				jQueryMX
			</a>
			
		</li>
		
		
			
			<li class="search-container active">
			<a class="sidebar-title" href="jQuery.View.html" data-search="jQuery.View">
				jQuery.View
			</a>
			
	<ul>
		
			
				
				
				<li class="search-container">
					<a class="page" href="view.deferreds.html" data-search="Using Deferreds with Views">
						Using Deferreds with Views
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="constructor" href="Jaml.html" data-search="Jaml">
						Jaml
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="Micro.html" data-search="Micro">
						Micro
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="property" href="jQuery.View.cache.html" data-search="jQuery.View.cache">
						cache
					</a>
				</li>
				
			
			
		
			
		
			
				
				
				<li class="search-container">
					<a class="property" href="jQuery.View.ext.html" data-search="jQuery.View.ext">
						ext
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.View.hookup.html" data-search="jQuery.View.hookup">
						hookup
					</a>
				</li>
				
			
			
		
			
		
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.View.register.html" data-search="jQuery.View.register">
						register
					</a>
				</li>
				
			
			
		
			
		
			
				
				
				<li class="search-container">
					<a class="add" href="jQuery.fn.html" data-search="jQuery.fn">
						jQuery.fn
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.after.html" data-search="jQuery.fn.after">
						jQuery.fn.after
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.append.html" data-search="jQuery.fn.append">
						jQuery.fn.append
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.before.html" data-search="jQuery.fn.before">
						jQuery.fn.before
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.html.html" data-search="jQuery.fn.html">
						jQuery.fn.html
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.prepend.html" data-search="jQuery.fn.prepend">
						jQuery.fn.prepend
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.replaceWith.html" data-search="jQuery.fn.replaceWith">
						jQuery.fn.replaceWith
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="function" href="jQuery.fn.text.html" data-search="jQuery.fn.text">
						jQuery.fn.text
					</a>
				</li>
				
			
			
		
			
				
				
				<li class="search-container">
					<a class="constructor" href="jQuery.tmpl.html" data-search="jQuery.tmpl">
						jQuery.tmpl
					</a>
				</li>
				
			
			
		
	</ul>

		</li>
			
		
	
</ul>
	</nav>
	
	
	
	<article class="content docs">
	
	
		
		<section class="title">
			<div class="heading">
<h1>jQuery.View</h1>
	<ul class="tags">
		<li>constructor</li>
	</ul>
	<span class="module">jquery/view</span>
	
</div>

<div class="sub-heading">
	
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
	
	
	
		<li><a href="../jquerymx/dist/jquery.view.js">download</a></li>
	
	
		<li><a href="../jquery/view/qunit.html">tests</a></li>
	
</ul>
<br />
		</section>
		
		
		
		<section class="contents">
		</section>
		
		
		

		
		<section class="description">
			<p>A JavaScript template framework.
View provides a uniform interface for using templates with
jQuery. When template engines <a href="jQuery.View.register.html">register</a>
themselves, you are able to:</p>
<ul>
<li>Use views with jQuery extensions <a href="jQuery.fn.after.html">after</a>, <a href="jQuery.fn.append.html">append</a>,
<a href="jQuery.fn.before.html">before</a>, <a href="jQuery.fn.html.html">html</a>, <a href="jQuery.fn.prepend.html">prepend</a>,
  <a href="jQuery.fn.replaceWith.html">replaceWith</a>, <a href="jQuery.fn.text.html">text</a>.</li>
<li>Template loading from html elements and external files.</li>
<li>Synchronous and asynchronous template loading.</li>
<li><a href="view.deferreds.html">Deferred Rendering</a>.</li>
<li>Template caching.</li>
<li>Bundling of processed templates in production builds.</li>
<li>Hookup jquery plugins directly in the template.</li>
</ul>
<p>The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.</p>
<h2>Use</h2>
<p>When using views, you're almost always wanting to insert the results
of a rendered template into the page. jQuery.View overwrites the
jQuery modifiers so using a view is as easy as:</p>
<pre><code>$(&quot;#foo&quot;).html('mytemplate.ejs',{message: 'hello world'})
</code></pre>
<p>This code:</p>
<ul>
<li><p>Loads the template a 'mytemplate.ejs'. It might look like:</p>
<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code></li>
<li><p>Renders it with {message: 'hello world'}, resulting in:</p>
<pre><code>&lt;div id='foo'>"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></li>
<li><p>Inserts the result into the foo element. Foo might look like:</p>
<pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></li>
</ul>
<h2>jQuery Modifiers</h2>
<p>You can use a template with the following jQuery modifiers:</p>
<table>
<tr><td><a href="jQuery.fn.after.html">after</a></td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.append.html">append</a> </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.before.html">before</a> </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.html.html">html</a> </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.prepend.html">prepend</a> </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.replaceWith.html">replaceWith</a> </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.text.html">text</a> </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>
</table>
<p>You always have to pass a string and an object (or function) for the jQuery modifier
to user a template.</p>
<h2>Template Locations</h2>
<p>View can load from script tags or from files.</p>
<h2>From Script Tags</h2>
<p>To load from a script tag, create a script tag with your template and an id like:</p>
<pre><code>&lt;script type='text/ejs' id='recipes'>
&lt;% for(var i=0; i &lt; recipes.length; i++){ %>
  &lt;li>&lt;%=recipes[i].name %>&lt;/li>
&lt;%} %>
&lt;/script></code></pre>
<p>Render with this template like:</p>
<pre><code class="language-js">$(&quot;#foo&quot;).html('recipes',recipeData)
</code></pre>
<p>Notice we passed the id of the element we want to render.</p>
<h2>From File</h2>
<p>You can pass the path of a template file location like:</p>
<pre><code>$(&quot;#foo&quot;).html('templates/recipes.ejs',recipeData)
</code></pre>
<p>However, you typically want to make the template work from whatever page they
are called from.  To do this, use // to look up templates from JMVC root:</p>
<pre><code>$(&quot;#foo&quot;).html('//app/views/recipes.ejs',recipeData)
</code></pre>
<p>Finally, the <a href="jQuery.Controller.prototype.view.html">controller/view</a> plugin can make looking
up a thread (and adding helpers) even easier:</p>
<pre><code>$(&quot;#foo&quot;).html( this.view('recipes', recipeData) )
</code></pre>
<h2>Packaging Templates</h2>
<p>If you're making heavy use of templates, you want to organize
them in files so they can be reused between pages and applications.</p>
<p>But, this organization would come at a high price
if the browser has to
retrieve each template individually. The additional
HTTP requests would slow down your app.</p>
<p>Fortunately, [steal.static.views steal.views] can build templates
into your production files. You just have to point to the view file like:</p>
<pre><code>steal.views('path/to/the/view.ejs');
</code></pre>
<h2>Asynchronous</h2>
<p>By default, retrieving requests is done synchronously. This is
fine because StealJS packages view templates with your JS download.</p>
<p>However, some people might not be using StealJS or want to delay loading
templates until necessary. If you have the need, you can
provide a callback paramter like:</p>
<pre><code>$(&quot;#foo&quot;).html('recipes',recipeData, function(result){
  this.fadeIn()
});
</code></pre>
<p>The callback function will be called with the result of the
rendered template and 'this' will be set to the original jQuery object.</p>
<h2>Deferreds (3.0.6)</h2>
<p>If you pass deferreds to $.View or any of the jQuery
modifiers, the view will wait until all deferreds resolve before
rendering the view.  This makes it a one-liner to make a request and
use the result to render a template.</p>
<p>The following makes a request for todos in parallel with the
todos.ejs template.  Once todos and template have been loaded, it with
render the view with the todos.</p>
<pre><code>$('#todos').html(&quot;todos.ejs&quot;,Todo.findAll());
</code></pre>
<h2>Just Render Templates</h2>
<p>Sometimes, you just want to get the result of a rendered
template without inserting it, you can do this with $.View:</p>
<pre><code>var out = $.View('path/to/template.jaml',{});
</code></pre>
<h2>Preloading Templates</h2>
<p>You can preload templates asynchronously like:</p>
<pre><code>$.get('path/to/template.jaml',{},function(){},'view');
</code></pre>
<h2>Supported Template Engines</h2>
<p>JavaScriptMVC comes with the following template languages:</p>
<ul>
<li><p>EmbeddedJS</p>
<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre></li>
<li><p>JAML</p>
<pre><code>h2(data.message);</code></pre></li>
<li><p>Micro</p>
<pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre></li>
<li><p>jQuery.Tmpl</p>
<pre><code>&lt;h2>${message}&lt;/h2></code></pre></li>
</ul>
<p>The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a>
template engine is supported in a 2nd party plugin.</p>
<h2>Using other Template Engines</h2>
<p>It's easy to integrate your favorite template into $.View and Steal.  Read
how in <a href="jQuery.View.register.html">jQuery.View.register</a>.</p>
<p>Looks up a template, processes it, caches it, then renders the template
with data and optional helpers.</p>
<p>With [stealjs StealJS], views are typically bundled in the production build.
This makes it ok to use views synchronously like:</p>
<pre><code class="language-js">$.View(&quot;//myplugin/views/init.ejs&quot;,{message: &quot;Hello World&quot;})
</code></pre>
<p>If you aren't using StealJS, it's best to use views asynchronously like:</p>
<pre><code class="language-js">$.View(&quot;//myplugin/views/init.ejs&quot;,
       {message: &quot;Hello World&quot;}, function(result){
  // do something with result
})
</code></pre>

		</section>
		

		
			
		
		
		
			<section class="signature">
				<h2 id="sig_">new jquerymx.View(view, data, helpers, callback)
</h2>
<div class="signature-wrapper">
<p>A JavaScript template framework.
View provides a uniform interface for using templates with
jQuery. When template engines <a href="jQuery.View.register.html">register</a>
themselves, you are able to:</p>
<ul>
<li>Use views with jQuery extensions <a href="jQuery.fn.after.html">after</a>, <a href="jQuery.fn.append.html">append</a>,
<a href="jQuery.fn.before.html">before</a>, <a href="jQuery.fn.html.html">html</a>, <a href="jQuery.fn.prepend.html">prepend</a>,
  <a href="jQuery.fn.replaceWith.html">replaceWith</a>, <a href="jQuery.fn.text.html">text</a>.</li>
<li>Template loading from html elements and external files.</li>
<li>Synchronous and asynchronous template loading.</li>
<li><a href="view.deferreds.html">Deferred Rendering</a>.</li>
<li>Template caching.</li>
<li>Bundling of processed templates in production builds.</li>
<li>Hookup jquery plugins directly in the template.</li>
</ul>
<p>The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.</p>
<h2>Use</h2>
<p>When using views, you're almost always wanting to insert the results
of a rendered template into the page. jQuery.View overwrites the
jQuery modifiers so using a view is as easy as:</p>
<pre><code>$(&quot;#foo&quot;).html('mytemplate.ejs',{message: 'hello world'})
</code></pre>
<p>This code:</p>
<ul>
<li><p>Loads the template a 'mytemplate.ejs'. It might look like:</p>
<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code></li>
<li><p>Renders it with {message: 'hello world'}, resulting in:</p>
<pre><code>&lt;div id='foo'>"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></li>
<li><p>Inserts the result into the foo element. Foo might look like:</p>
<pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code></li>
</ul>
<h2>jQuery Modifiers</h2>
<p>You can use a template with the following jQuery modifiers:</p>
<table>
<tr><td><a href="jQuery.fn.after.html">after</a></td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.append.html">append</a> </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.before.html">before</a> </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.html.html">html</a> </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.prepend.html">prepend</a> </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.replaceWith.html">replaceWith</a> </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>
<tr><td><a href="jQuery.fn.text.html">text</a> </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>
</table>
<p>You always have to pass a string and an object (or function) for the jQuery modifier
to user a template.</p>
<h2>Template Locations</h2>
<p>View can load from script tags or from files.</p>
<h2>From Script Tags</h2>
<p>To load from a script tag, create a script tag with your template and an id like:</p>
<pre><code>&lt;script type='text/ejs' id='recipes'>
&lt;% for(var i=0; i &lt; recipes.length; i++){ %>
  &lt;li>&lt;%=recipes[i].name %>&lt;/li>
&lt;%} %>
&lt;/script></code></pre>
<p>Render with this template like:</p>
<pre><code class="language-js">$(&quot;#foo&quot;).html('recipes',recipeData)
</code></pre>
<p>Notice we passed the id of the element we want to render.</p>
<h2>From File</h2>
<p>You can pass the path of a template file location like:</p>
<pre><code>$(&quot;#foo&quot;).html('templates/recipes.ejs',recipeData)
</code></pre>
<p>However, you typically want to make the template work from whatever page they
are called from.  To do this, use // to look up templates from JMVC root:</p>
<pre><code>$(&quot;#foo&quot;).html('//app/views/recipes.ejs',recipeData)
</code></pre>
<p>Finally, the <a href="jQuery.Controller.prototype.view.html">controller/view</a> plugin can make looking
up a thread (and adding helpers) even easier:</p>
<pre><code>$(&quot;#foo&quot;).html( this.view('recipes', recipeData) )
</code></pre>
<h2>Packaging Templates</h2>
<p>If you're making heavy use of templates, you want to organize
them in files so they can be reused between pages and applications.</p>
<p>But, this organization would come at a high price
if the browser has to
retrieve each template individually. The additional
HTTP requests would slow down your app.</p>
<p>Fortunately, [steal.static.views steal.views] can build templates
into your production files. You just have to point to the view file like:</p>
<pre><code>steal.views('path/to/the/view.ejs');
</code></pre>
<h2>Asynchronous</h2>
<p>By default, retrieving requests is done synchronously. This is
fine because StealJS packages view templates with your JS download.</p>
<p>However, some people might not be using StealJS or want to delay loading
templates until necessary. If you have the need, you can
provide a callback paramter like:</p>
<pre><code>$(&quot;#foo&quot;).html('recipes',recipeData, function(result){
  this.fadeIn()
});
</code></pre>
<p>The callback function will be called with the result of the
rendered template and 'this' will be set to the original jQuery object.</p>
<h2>Deferreds (3.0.6)</h2>
<p>If you pass deferreds to $.View or any of the jQuery
modifiers, the view will wait until all deferreds resolve before
rendering the view.  This makes it a one-liner to make a request and
use the result to render a template.</p>
<p>The following makes a request for todos in parallel with the
todos.ejs template.  Once todos and template have been loaded, it with
render the view with the todos.</p>
<pre><code>$('#todos').html(&quot;todos.ejs&quot;,Todo.findAll());
</code></pre>
<h2>Just Render Templates</h2>
<p>Sometimes, you just want to get the result of a rendered
template without inserting it, you can do this with $.View:</p>
<pre><code>var out = $.View('path/to/template.jaml',{});
</code></pre>
<h2>Preloading Templates</h2>
<p>You can preload templates asynchronously like:</p>
<pre><code>$.get('path/to/template.jaml',{},function(){},'view');
</code></pre>
<h2>Supported Template Engines</h2>
<p>JavaScriptMVC comes with the following template languages:</p>
<ul>
<li><p>EmbeddedJS</p>
<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre></li>
<li><p>JAML</p>
<pre><code>h2(data.message);</code></pre></li>
<li><p>Micro</p>
<pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre></li>
<li><p>jQuery.Tmpl</p>
<pre><code>&lt;h2>${message}&lt;/h2></code></pre></li>
</ul>
<p>The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a>
template engine is supported in a 2nd party plugin.</p>
<h2>Using other Template Engines</h2>
<p>It's easy to integrate your favorite template into $.View and Steal.  Read
how in <a href="jQuery.View.register.html">jQuery.View.register</a>.</p>
<p>Looks up a template, processes it, caches it, then renders the template
with data and optional helpers.</p>
<p>With [stealjs StealJS], views are typically bundled in the production build.
This makes it ok to use views synchronously like:</p>
<pre><code class="language-js">$.View(&quot;//myplugin/views/init.ejs&quot;,{message: &quot;Hello World&quot;})
</code></pre>
<p>If you aren't using StealJS, it's best to use views asynchronously like:</p>
<pre><code class="language-js">$.View(&quot;//myplugin/views/init.ejs&quot;,
       {message: &quot;Hello World&quot;}, function(result){
  // do something with result
})
</code></pre>


	<h3>Parameters</h3>

	<ol class="parameters">
		
		<li class="parameter">
			<h4>view
				<code>{String}</code></h4>
			<div class="description">
				<p>The url or id of an element to use as the template's source.</p>

			</div>
			
			
			
		</li>
		
		<li class="parameter">
			<h4>data
				<code>{Object}</code></h4>
			<div class="description">
				<p>The data to be passed to the view.</p>

			</div>
			
			
			
		</li>
		
		<li class="parameter">
			<h4>helpers
				<code>{Object}</code><span class="pull-right optional">Optional</span></h4>
			<div class="description">
				<p>Optional helper functions the view might use. Not all
templates support helpers.</p>

			</div>
			
			
			
		</li>
		
		<li class="parameter">
			<h4>callback
				<code>{Object}</code><span class="pull-right optional">Optional</span></h4>
			<div class="description">
				<p>Optional callback function.  If present, the template is
retrieved asynchronously.  This is a good idea if you aren't compressing the templates
into your view.</p>

			</div>
			
			
			
		</li>
		
	</ol>


	<h3>Returns</h3>
	<div class="returns">
		<h4><code>{String}</code></h4>
		<div class="description">
			<p>The rendered result of the view or if deferreds
are passed, a deferred that will resolve to
the rendered result of the view.</p>

		</div>
		
		
	</div>
	





</div>

			</section>
		
		

		
		

		

		
	
	
	</article>
	
	

</div>





	
	<footer>
		<nav class="container">
			<a class="brand javascriptmvc" href="index.html"></a>
		</nav>
	</footer>
	
	
	<script type="text/javascript">
		var docObject = {"type":"constructor","name":"jQuery.View","params":[{"types":[{"type":"String"}],"name":"view","description":"The url or id of an element to use as the template's source."},{"types":[{"type":"Object","options":[]}],"name":"data","description":"The data to be passed to the view."},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"helpers","description":"Optional helper functions the view might use. Not all\ntemplates support helpers."},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"callback","description":"Optional callback function.  If present, the template is \nretrieved asynchronously.  This is a good idea if you aren't compressing the templates\ninto your view."}],"parent":"jquerymx","src":"view/view.js","line":11,"codeLine":225,"description":"A JavaScript template framework. \nView provides a uniform interface for using templates with \njQuery. When template engines [jQuery.View.register register] \nthemselves, you are able to:\n\n - Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],\n  [jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],\n  [jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text].\n - Template loading from html elements and external files.\n - Synchronous and asynchronous template loading.\n - [view.deferreds Deferred Rendering].\n - Template caching.\n - Bundling of processed templates in production builds.\n - Hookup jquery plugins directly in the template.\n\nThe [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.\n\n## Use\n\n\nWhen using views, you're almost always wanting to insert the results \nof a rendered template into the page. jQuery.View overwrites the \njQuery modifiers so using a view is as easy as: \n\n    $(\"#foo\").html('mytemplate.ejs',{message: 'hello world'})\n\nThis code:\n\n - Loads the template a 'mytemplate.ejs'. It might look like:\n   <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code>\n \n - Renders it with {message: 'hello world'}, resulting in:\n   <pre><code>&lt;div id='foo'>\"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>\n \n - Inserts the result into the foo element. Foo might look like:\n   <pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>\n\n## jQuery Modifiers\n\nYou can use a template with the following jQuery modifiers:\n\n<table>\n<tr><td>[jQuery.fn.after after]</td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.append append] </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.before before] </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.html html] </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.prepend prepend] </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.replaceWith replaceWith] </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>\n<tr><td>[jQuery.fn.text text] </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>\n</table>\n\nYou always have to pass a string and an object (or function) for the jQuery modifier \nto user a template.\n\n## Template Locations\n\nView can load from script tags or from files. \n\n## From Script Tags\n\nTo load from a script tag, create a script tag with your template and an id like: \n\n<pre><code>&lt;script type='text/ejs' id='recipes'>\n&lt;% for(var i=0; i &lt; recipes.length; i++){ %>\n  &lt;li>&lt;%=recipes[i].name %>&lt;/li>\n&lt;%} %>\n&lt;/script></code></pre>\n\nRender with this template like: \n\n\n```js\n$(\"#foo\").html('recipes',recipeData)\n```\nNotice we passed the id of the element we want to render.\n\n## From File\n\nYou can pass the path of a template file location like:\n\n    $(\"#foo\").html('templates/recipes.ejs',recipeData)\n\nHowever, you typically want to make the template work from whatever page they \nare called from.  To do this, use // to look up templates from JMVC root:\n\n    $(\"#foo\").html('//app/views/recipes.ejs',recipeData)\n    \nFinally, the [jQuery.Controller.prototype.view controller/view] plugin can make looking\nup a thread (and adding helpers) even easier:\n\n    $(\"#foo\").html( this.view('recipes', recipeData) )\n\n## Packaging Templates\n\nIf you're making heavy use of templates, you want to organize \nthem in files so they can be reused between pages and applications.\n\nBut, this organization would come at a high price \nif the browser has to \nretrieve each template individually. The additional \nHTTP requests would slow down your app. \n\nFortunately, [steal.static.views steal.views] can build templates \ninto your production files. You just have to point to the view file like: \n\n    steal.views('path/to/the/view.ejs');\n\n## Asynchronous\n\nBy default, retrieving requests is done synchronously. This is \nfine because StealJS packages view templates with your JS download. \n\nHowever, some people might not be using StealJS or want to delay loading \ntemplates until necessary. If you have the need, you can \nprovide a callback paramter like: \n\n    $(\"#foo\").html('recipes',recipeData, function(result){\n      this.fadeIn()\n    });\n\nThe callback function will be called with the result of the \nrendered template and 'this' will be set to the original jQuery object.\n\n## Deferreds (3.0.6)\n\nIf you pass deferreds to $.View or any of the jQuery \nmodifiers, the view will wait until all deferreds resolve before \nrendering the view.  This makes it a one-liner to make a request and \nuse the result to render a template. \n\nThe following makes a request for todos in parallel with the \ntodos.ejs template.  Once todos and template have been loaded, it with\nrender the view with the todos.\n\n    $('#todos').html(\"todos.ejs\",Todo.findAll());\n\n## Just Render Templates\n\nSometimes, you just want to get the result of a rendered \ntemplate without inserting it, you can do this with $.View: \n\n    var out = $.View('path/to/template.jaml',{});\n    \n## Preloading Templates\n\nYou can preload templates asynchronously like:\n\n    $.get('path/to/template.jaml',{},function(){},'view');\n\n## Supported Template Engines\n\nJavaScriptMVC comes with the following template languages:\n\n  - EmbeddedJS\n    <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre>\n    \n  - JAML\n    <pre><code>h2(data.message);</code></pre>\n    \n  - Micro\n    <pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre>\n    \n  - jQuery.Tmpl\n    <pre><code>&lt;h2>${message}&lt;/h2></code></pre>\n\nThe popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a> \ntemplate engine is supported in a 2nd party plugin.\n\n## Using other Template Engines\n\nIt's easy to integrate your favorite template into $.View and Steal.  Read \nhow in [jQuery.View.register].\n\n\nLooks up a template, processes it, caches it, then renders the template\nwith data and optional helpers.\n\nWith [stealjs StealJS], views are typically bundled in the production build.\nThis makes it ok to use views synchronously like:\n\n\n```js\n$.View(\"//myplugin/views/init.ejs\",{message: \"Hello World\"})\n```\nIf you aren't using StealJS, it's best to use views asynchronously like:\n\n\n```js\n$.View(\"//myplugin/views/init.ejs\",\n       {message: \"Hello World\"}, function(result){\n  // do something with result\n})\n```","plugin":"jquery/view","test":"jquery/view/qunit.html","download":"dist/jquery.view.js","returns":{"types":[{"type":"String"}],"description":"The rendered result of the view or if deferreds \nare passed, a deferred that will resolve to\nthe rendered result of the view."},"glob":{"ignore":"{node_modules,bower_components}/**/*","pattern":"**/*.{md,js}","cwd":"/Users/webmech/dev/jquerymx"},"debug":true,"dest":"/Users/webmech/dev/docs","generators":["html"],"docConfigDest":"../jquerymx/documentjs.json","project":{}};
	</script>
	
	
		<script>
		  steal = {
		    instantiated: {
		      "bundles/static.css!$css" : null
		    }
		  }
		</script>
		<script type='text/javascript' 
				data-main="static"
				data-config="./static/config.js"
				src="./static/steal.production.js"
	    		bundles-path="bundles"></script>
	
</body>

</html>
